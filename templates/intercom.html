{% extends "base.html" %}

{% block title %}Intercom - Birdbox{% endblock %}

{% block head %}
<style>
    /* Full viewport layout */
    .intercom-container {
        height: 100vh;
        display: flex;
        flex-direction: column;
        margin: 0;
        padding: 0;
    }

    /* Video container fills remaining space */
    .video-container {
        flex-grow: 1;
        background-color: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }

    /* Video maintains aspect ratio while filling container */
    #videoFeed {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    /* Button container below video */
    .button-container {
        background-color: #000;
        padding: 12px 16px;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    /* Buttons stack vertically with same width */
    .button-container .btn {
        width: 100%;
        padding: 12px 16px;
        font-size: 1rem;
        font-weight: 500;
    }

    /* Fixed status bar at bottom - single line */
    .status-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        height: 44px;
        background-color: #f8f9fa;
        border-top: 2px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        z-index: 1000;
    }

    /* Connection status on the left */
    .connection-status {
        font-weight: 600;
        font-size: 0.95rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Ad-hoc status message on the right */
    .status-message {
        font-size: 0.85rem;
        text-align: right;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Reserve space for fixed status bar */
    .button-container {
        padding-bottom: 44px;
    }

    /* Responsive adjustments for smaller screens */
    @media (max-width: 576px) {
        .status-bar {
            padding: 0 16px;
            height: 40px;
        }

        .button-container {
            padding: 10px 12px 40px 12px;
            gap: 8px;
        }

        .button-container .btn {
            padding: 10px 14px;
            font-size: 0.95rem;
        }

        .connection-status {
            font-size: 0.875rem;
        }

        .status-message {
            font-size: 0.8rem;
        }
    }

    /* Hide base template container padding for full-screen layout */
    body.p-4 {
        padding: 0 !important;
    }

    body .container {
        padding: 0 !important;
        margin: 0 !important;
        max-width: 100% !important;
    }
</style>
{% endblock %}

{% block body %}
<div class="intercom-container">
    <!-- Video fills remaining space -->
    <div class="video-container">
        <video id="videoFeed" autoplay playsinline muted></video>
    </div>

    <!-- Button container below video -->
    <div class="button-container">
        <button id="openGatesBtn" class="btn btn-warning" hx-post="/api/open-gates" hx-swap="none">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                class="bi bi-door-open-fill" viewBox="0 0 16 16">
                <path
                    d="M1.5 15a.5.5 0 0 0 0 1h13a.5.5 0 0 0 0-1H13V2.5A1.5 1.5 0 0 0 11.5 1H11V.5a.5.5 0 0 0-.57-.495l-7 1A.5.5 0 0 0 3 1.5V15zM11 2h.5a.5.5 0 0 1 .5.5V15h-1zm-2.5 8c-.276 0-.5-.448-.5-1s.224-1 .5-1 .5.448.5 1-.224 1-.5 1" />
            </svg>
            Open Gates
        </button>

        <button id="transmitBtn" class="btn btn-secondary" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                class="bi bi-mic-fill" viewBox="0 0 16 16">
                <path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0z" />
                <path
                    d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5" />
            </svg>
            <span id="transmitText">Transmit</span>
        </button>
    </div>

    <!-- Fixed status bar at bottom -->
    <div class="status-bar">
        <div id="connectionStatus" class="connection-status text-secondary">
            Connecting...
        </div>
        <div id="statusMessage" class="status-message"></div>
    </div>
</div>

<!-- Audio element for doorbell audio -->
<audio id="audio" autoplay playsinline></audio>
{% endblock %}

{% block scripts %}
<script>
    const log = (...args) => console.log('[webrtc]', ...args);
    const connectionStatusEl = document.getElementById('connectionStatus');
    const statusMessageEl = document.getElementById('statusMessage');
    const audioEl = document.getElementById('audio');
    const transmitBtn = document.getElementById('transmitBtn');
    const transmitText = document.getElementById('transmitText');

    let pc = null;
    let socket = null;
    let localStream = null;
    let isTransmitting = false;
    let othersTransmitting = false;

    function setConnectionStatus(text, colorClass) {
        connectionStatusEl.textContent = text;
        connectionStatusEl.className = 'connection-status ' + (colorClass || 'text-secondary');
    }

    function setStatusMessage(text, colorClass) {
        statusMessageEl.textContent = text;
        statusMessageEl.className = 'status-message ' + (colorClass || 'text-muted');
    }

    function updateTransmitButton() {
        if (!pc || pc.connectionState !== 'connected') {
            transmitBtn.disabled = true;
            transmitBtn.className = 'btn btn-secondary';
            transmitText.textContent = 'Transmit';
            return;
        }

        if (othersTransmitting) {
            transmitBtn.disabled = true;
            transmitBtn.className = 'btn btn-warning';
            transmitText.textContent = 'Line Busy';
        } else if (isTransmitting) {
            transmitBtn.disabled = false;
            transmitBtn.className = 'btn btn-danger';
            transmitText.textContent = 'Stop';
        } else {
            transmitBtn.disabled = false;
            transmitBtn.className = 'btn btn-success';
            transmitText.textContent = 'Transmit';
        }
    }

    async function startTransmitting() {
        if (isTransmitting || othersTransmitting) return;

        log('Starting transmission...');

        // Optimistically set transmitting state
        isTransmitting = true;
        updateTransmitButton();

        try {
            // Request microphone access if we don't have it
            if (!localStream) {
                log('Requesting microphone access...');
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                    }
                });
                log('Microphone access granted');
            }

            // Add microphone track to peer connection (this will trigger on_track on server)
            const audioTrack = localStream.getAudioTracks()[0];

            // Check if we already have a sender for our local audio
            let sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio' && s.track.id === audioTrack.id);

            if (!sender) {
                // Add the track - this triggers renegotiation
                sender = pc.addTrack(audioTrack, localStream);
                log('Added microphone track to peer connection');

                // Create and send new offer to trigger renegotiation
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
                log('Sent renegotiation offer with microphone track');
            } else {
                log('Microphone track already added');
            }

            // Request transmission from server
            socket.send(JSON.stringify({ type: 'start_ptt' }));

        } catch (e) {
            console.error('Failed to start transmission:', e);
            alert('Failed to access microphone: ' + e.message);
            // Reset state on error
            isTransmitting = false;
            updateTransmitButton();
        }
    }

    async function stopTransmitting() {
        if (!isTransmitting) return;

        log('Stopping transmission...');

        // Mark as inactive
        isTransmitting = false;
        // Clear others transmitting flag when we stop
        othersTransmitting = false;
        updateTransmitButton();

        // Remove microphone track from peer connection
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            const sender = pc.getSenders().find(s => s.track && s.track.id === audioTrack.id);
            if (sender) {
                pc.removeTrack(sender);
                log('Removed microphone track from peer connection');

                // Create and send new offer to trigger renegotiation
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
                log('Sent renegotiation offer without microphone track');
            }
        }

        // Notify server
        socket.send(JSON.stringify({ type: 'stop_ptt' }));
    }

    function toggleTransmit() {
        if (isTransmitting) {
            stopTransmitting();
        } else {
            startTransmitting();
        }
    }

    // Transmit button event handler - simple toggle on click
    transmitBtn.addEventListener('click', toggleTransmit);

    async function connect() {
        setConnectionStatus('Connecting...', 'text-warning');
        pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        // Ensure the offer contains media m-lines for receiving server audio and video
        try {
            pc.addTransceiver('audio', { direction: 'recvonly' });
            pc.addTransceiver('video', { direction: 'recvonly' });
        } catch (e) {
            log('addTransceiver failed (older browser?)', e);
        }

        pc.onicecandidate = (e) => {
            if (e.candidate) {
                log('local ICE candidate:', {
                    candidate: e.candidate.candidate,
                    sdpMid: e.candidate.sdpMid,
                    sdpMLineIndex: e.candidate.sdpMLineIndex,
                    type: e.candidate.type,
                    protocol: e.candidate.protocol,
                    address: e.candidate.address,
                    port: e.candidate.port
                });
                socket.send(JSON.stringify({
                    type: 'candidate',
                    candidate: e.candidate.candidate,
                    sdpMid: e.candidate.sdpMid,
                    sdpMLineIndex: e.candidate.sdpMLineIndex
                }));
            } else {
                log('✓ ICE candidate gathering complete');
            }
        };
        pc.onicegatheringstatechange = () => {
            log('ICE gathering state changed:', pc.iceGatheringState);
        };
        pc.onsignalingstatechange = () => {
            log('signaling state changed:', pc.signalingState);
        };
        pc.oniceconnectionstatechange = () => {
            log('ICE connection state changed:', pc.iceConnectionState);
            switch (pc.iceConnectionState) {
                case 'connected':
                    setConnectionStatus('Connected', 'text-success');
                    log('✓ ICE connection established');
                    break;
                case 'disconnected':
                    setConnectionStatus('Disconnected', 'text-danger');
                    log('⚠ ICE connection disconnected');
                    break;
                case 'failed':
                    setConnectionStatus('Failed', 'text-danger');
                    log('✗ ICE connection failed');
                    break;
                case 'checking':
                    setConnectionStatus('Checking...', 'text-warning');
                    log('⋯ ICE checking connectivity...');
                    break;
                case 'new':
                    log('ICE state: new');
                    break;
                case 'completed':
                    log('✓ ICE connection completed');
                    break;
                case 'closed':
                    setConnectionStatus('Closed', 'text-secondary');
                    log('ICE connection closed');
                    break;
            }
            updateTransmitButton();
        };
        pc.onconnectionstatechange = () => {
            log('peer connection state changed:', pc.connectionState);
            updateTransmitButton();
        };
        pc.ontrack = (e) => {
            log('remote track received', e.track.kind, e.streams[0]);
            if (e.track.kind === 'audio') {
                audioEl.srcObject = e.streams[0];
            } else if (e.track.kind === 'video') {
                document.getElementById('videoFeed').srcObject = e.streams[0];
            }
        };

        socket = new WebSocket(`ws://${location.host}/ws`);
        socket.onopen = async () => {
            log('✓ WebSocket connected');
            const offer = await pc.createOffer();
            log('created offer, setting local description...');
            await pc.setLocalDescription(offer);
            log('sending offer to server');
            socket.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
        };
        socket.onmessage = async (ev) => {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'answer') {
                log('✓ received answer from server');
                await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
                log('remote description set');
            } else if (msg.type === 'candidate') {
                log('remote ICE candidate:', {
                    candidate: msg.candidate,
                    sdpMid: msg.sdpMid,
                    sdpMLineIndex: msg.sdpMLineIndex
                });
                try {
                    await pc.addIceCandidate({
                        candidate: msg.candidate,
                        sdpMid: msg.sdpMid ?? null,
                        sdpMLineIndex: msg.sdpMLineIndex ?? null,
                    });
                    log('✓ remote candidate added');
                } catch (e) {
                    console.error('✗ addIceCandidate failed:', e);
                }
            } else if (msg.type === 'ptt_granted') {
                log('✓ Transmission granted');
                // Server confirmed transmission lock acquired
            } else if (msg.type === 'ptt_denied') {
                log('✗ Transmission denied:', msg.reason);
                // Server denied - line is busy, revert state
                isTransmitting = false;
                updateTransmitButton();

                // Revert by removing the track
                if (localStream) {
                    const audioTrack = localStream.getAudioTracks()[0];
                    const sender = pc.getSenders().find(s => s.track && s.track.id === audioTrack.id);
                    if (sender) {
                        pc.removeTrack(sender);
                    }
                }
            } else if (msg.type === 'ptt_state') {
                log('Transmission state update:', msg.transmitting);
                // If someone started transmitting and it's not us, set othersTransmitting
                // If someone stopped transmitting, always clear othersTransmitting
                if (msg.transmitting && !isTransmitting) {
                    othersTransmitting = true;
                } else if (!msg.transmitting) {
                    othersTransmitting = false;
                }
                updateTransmitButton();
            }
        };
        socket.onclose = () => {
            log('✗ WebSocket closed');
            setConnectionStatus('Disconnected', 'text-danger');
        };
        socket.onerror = (e) => {
            console.error('✗ WebSocket error:', e);
            setConnectionStatus('Error', 'text-danger');
        };
    }

    // Auto-connect on page load
    document.addEventListener('DOMContentLoaded', () => {
        log('Auto-connecting to intercom...');
        connect();
    });

    // Handle gates button response
    document.getElementById('openGatesBtn').addEventListener('htmx:afterRequest', function (evt) {
        if (evt.detail.successful) {
            // Success response
            setStatusMessage('Opened Gates', 'text-success');
            setTimeout(() => {
                setStatusMessage('', 'text-muted');
            }, 5000);
        } else {
            // Error response
            let errorMsg = 'Unknown error';
            if (evt.detail.xhr && evt.detail.xhr.responseText) {
                errorMsg = evt.detail.xhr.responseText;
            } else if (!evt.detail.xhr) {
                errorMsg = 'Network error';
            }
            setStatusMessage('Opening gates Failed: ' + errorMsg, 'text-danger');
            setTimeout(() => {
                setStatusMessage('', 'text-muted');
            }, 5000);
        }
    });
</script>
{% endblock %}
